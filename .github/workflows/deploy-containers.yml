name: Deploy Containers to AWS Dev

on:
  workflow_run:
    workflows: ['Monorepo pipeline - quality']
    branches: ['main']
    types:
      - completed

env:
  AWS_REGION: eu-west-1
  AWS_SHARED_ACCOUNT_ID: 592944621100
  AWS_DEV_ACCOUNT_ID: 555454216281

permissions:
  id-token: write # Required f. IAM Token
  contents: read

jobs:
  detect-affected:
    name: Detect affected containers
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    outputs:
      affected: ${{ steps.set-affected.outputs.affected }}
      unaffected: ${{ steps.set-affected.outputs.unaffected }}
      has_affected: ${{ steps.set-affected.outputs.has_affected }}
      has_unaffected: ${{ steps.set-affected.outputs.has_unaffected }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: 20.x

      - name: Set NX SHAs
        uses: nrwl/nx-set-shas@v4

      - name: Determine affected containers
        id: set-affected
        run: |
          ALL_CONTAINERS='["official-journal-api","official-journal-admin-api","official-journal-application-api","official-journal-web","regulations-api","legal-gazette-api","legal-gazette-web","legal-gazette-application-web","legal-gazette-public-web"]'

          mkdir -p /tmp/nx-tmp && npm install --prefix /tmp/nx-tmp --no-save --ignore-scripts --legacy-peer-deps --no-audit --no-fund nx@22.5.1
          mkdir -p node_modules && cp -r /tmp/nx-tmp/node_modules/* node_modules/

          echo "Log out what show projects returns"
          npx nx show projects --affected --type=app

          echo "Determining affected projects with nx"
          AFFECTED_PROJECTS=$(npx nx show projects --affected --type=app 2>/dev/null || echo "")

          AFFECTED_CONTAINERS="[]"
          UNAFFECTED_CONTAINERS="[]"

          for container in $(echo $ALL_CONTAINERS | jq -r '.[]'); do
            if echo "$AFFECTED_PROJECTS" | grep -q "^${container}$"; then
              AFFECTED_CONTAINERS=$(echo $AFFECTED_CONTAINERS | jq -c --arg c "$container" '. + [$c]')
            else
              UNAFFECTED_CONTAINERS=$(echo $UNAFFECTED_CONTAINERS | jq -c --arg c "$container" '. + [$c]')
            fi
          done

          echo "affected=$AFFECTED_CONTAINERS" >> $GITHUB_OUTPUT
          echo "unaffected=$UNAFFECTED_CONTAINERS" >> $GITHUB_OUTPUT

          HAS_AFFECTED=$([ "$(echo $AFFECTED_CONTAINERS | jq length)" -gt 0 ] && echo "true" || echo "false")
          HAS_UNAFFECTED=$([ "$(echo $UNAFFECTED_CONTAINERS | jq length)" -gt 0 ] && echo "true" || echo "false")

          echo "has_affected=$HAS_AFFECTED" >> $GITHUB_OUTPUT
          echo "has_unaffected=$HAS_UNAFFECTED" >> $GITHUB_OUTPUT

          echo "### Affected Containers" >> $GITHUB_STEP_SUMMARY
          echo "$AFFECTED_CONTAINERS" | jq -r '.[]' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Unaffected Containers (will re-tag)" >> $GITHUB_STEP_SUMMARY
          echo "$UNAFFECTED_CONTAINERS" | jq -r '.[]' | sed 's/^/- /' >> $GITHUB_STEP_SUMMARY

  build-affected:
    needs: detect-affected
    if: ${{ needs.detect-affected.outputs.has_affected == 'true' }}
    strategy:
      matrix:
        container: ${{ fromJson(needs.detect-affected.outputs.affected) }}
      fail-fast: false
    name: 'Build: ${{ matrix.container }}'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: 'true'

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: 20.x

      - name: Monorepo install
        uses: ./.github/actions/yarn-install

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_SHARED_ACCOUNT_ID }}:role/shared-github-ci-role
          role-session-name: GitHub-Action-Role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Docker Metadata
        uses: docker/metadata-action@v4
        id: meta
        with:
          images: '${{ steps.login-ecr.outputs.registry }}/${{ matrix.container }}'
          tags: |
            latest
            type=sha,prefix=sha-,format=long
            type=ref,event=branch
            type=ref,event=pr
            type=ref,event=tag

      - name: patch submodules
        run: yarn run postinstall

      - name: Build and push image
        run: yarn nx run ${{ matrix.container }}:container
        env:
          INPUT_GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          INPUT_TAGS: ${{ steps.meta.outputs.tags }}
          INPUT_PUSH: true

  retag-unaffected:
    needs: detect-affected
    if: ${{ needs.detect-affected.outputs.has_unaffected == 'true' }}
    strategy:
      matrix:
        container: ${{ fromJson(needs.detect-affected.outputs.unaffected) }}
      fail-fast: false
    name: 'Re-tag: ${{ matrix.container }}'
    runs-on: ubuntu-latest
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_SHARED_ACCOUNT_ID }}:role/shared-github-ci-role
          role-session-name: GitHub-Action-Role
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Copy latest tag to sha-${{ github.sha }}
        run: |
          SHA="${{ github.sha }}"
          REPO="${{ matrix.container }}"

          echo "Re-tagging ${REPO}:latest as sha-${SHA}"

          MANIFEST=$(aws ecr batch-get-image \
            --repository-name "$REPO" \
            --image-ids imageTag=latest \
            --query 'images[].imageManifest' \
            --output text)

          if [ -z "$MANIFEST" ] || [ "$MANIFEST" = "None" ]; then
            echo "::error::No 'latest' image found for ${REPO}. Cannot re-tag."
            exit 1
          fi

          aws ecr put-image \
            --repository-name "$REPO" \
            --image-tag "sha-${SHA}" \
            --image-manifest "$MANIFEST" 2>/dev/null || {
              echo "::warning::Tag sha-${SHA} may already exist for ${REPO}, verifying..."
              EXISTING=$(aws ecr batch-get-image \
                --repository-name "$REPO" \
                --image-ids imageTag="sha-${SHA}" \
                --query 'images[].imageManifest' \
                --output text)
              if [ -n "$EXISTING" ] && [ "$EXISTING" != "None" ]; then
                echo "Tag already exists, continuing."
              else
                echo "::error::Failed to re-tag ${REPO}"
                exit 1
              fi
            }

  deploy-to-dev:
    runs-on: ubuntu-latest
    needs: [detect-affected, build-affected, retag-unaffected]
    if: |
      always() &&
      needs.detect-affected.outputs.has_affected == 'true' &&
      needs.build-affected.result == 'success' &&
      (needs.retag-unaffected.result == 'success' || needs.retag-unaffected.result == 'skipped')
    environment: development
    strategy:
      matrix:
        container: ${{ fromJson(needs.detect-affected.outputs.affected) }}
      fail-fast: false
    name: Deploy to ${{ matrix.container }} - dev
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ env.AWS_DEV_ACCOUNT_ID }}:role/dev-github-ci-role
          role-session-name: GitHub-Action-Role
          aws-region: ${{ env.AWS_REGION }}

      - name: Deploy to Amazon ECS
        run: |
          aws ecs update-service \
            --cluster dev-dmr-utgafa \
            --service ${{ matrix.container }} \
            --force-new-deployment

      - name: Wait for service to stabilize
        run: |
          aws ecs wait services-stable \
            --cluster dev-dmr-utgafa \
            --services ${{ matrix.container }}
